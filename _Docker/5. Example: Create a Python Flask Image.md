# 1. Example

Create work folder, add work folder to workspace, create environment

![Python_VS_Code](/_Docker/imgs/Docker_example_1.png)

Activate the environment

![Activte environment](/_Docker/imgs/Docker_example_2.png)

Install flask in the environment

![Install flask](/_Docker/imgs/Docker_example_3.png)

cd back to project folder, then set flask environment, and flash run

![Run flask](/_Docker/imgs/Docker_example_4.png)

run in browser

![Run browser](/_Docker/imgs/Docker_example_5.png)

create a dockerfile, install dockerfile plug ins

![create_dockerfile](/_Docker/imgs/Docker_example_6.png)

prepare a dockerfile

![prepare_dockerfile](/_Docker/imgs/Docker_example_7.png)

build an image and list

![build_image](/_Docker/imgs/Docker_example_8.png)

create a container, and run

![run_container](/_Docker/imgs/Docker_example_9.png)

how to visit flask-demo web service? This involves port forwarding. Rewrite Dockerfile as follows and then redo all the above

![rewrite_dockfile](/_Docker/imgs/Docker_example_10.png)

re-create container with following codes

![re-create_container](/_Docker/imgs/Docker_example_11.png)

open browser and visit http://127.0.0.1:5000/

# 2. Dockerfile best practice

put commands which need to be changed frequently in the end

![commands_position](/_Docker/imgs/Docker_example_12.png)

# 3. .dockerignore

as as .gitignore
ignore sending certain files/folders to docker daemon
or protect certain file/data privacy

# 4. image multi-stage build

```dockerfile
FROM gcc:9.4

COPY hello.c /src/hello.c

WORKDIR /src

RUN gcc --static -o hello hello.c

ENTRYPOINT [ "/src/hello" ]

CMD []
```
```dockerfile
$ docker build -t hello .
Sending build context to Docker daemon   5.12kB
Step 1/6 : FROM gcc:9.4
---> be1d0d9ce039
Step 2/6 : COPY hello.c /src/hello.c
---> Using cache
---> 70a624e3749b
Step 3/6 : WORKDIR /src
---> Using cache
---> 24e248c6b27c
Step 4/6 : RUN gcc --static -o hello hello.c
---> Using cache
---> db8ae7b42aff
Step 5/6 : ENTRYPOINT [ "/src/hello" ]
---> Using cache
---> 7f307354ee45
Step 6/6 : CMD []
---> Using cache
---> 7cfa0cbe4e2a
Successfully built 7cfa0cbe4e2a
Successfully tagged hello:latest
$ docker image ls
REPOSITORY     TAG          IMAGE ID       CREATED       SIZE
hello          latest       7cfa0cbe4e2a   2 hours ago   1.14GB
gcc            9.4          be1d0d9ce039   9 days ago    1.14GB
$ docker run --rm -it hello docker
hello docker
$ docker run --rm -it hello world
hello world
$ docker run --rm -it hello friends
hello friends
$
```
Image is very large, 1.14G. This is because GCC is very large about 1.14G. We probably do not need large GCC environment, maybe a small alpine environment is enough.
Therefore we need multi-stage build
```dockerfile
FROM gcc:9.4 AS builder

COPY hello.c /src/hello.c

WORKDIR /src

RUN gcc --static -o hello hello.c



FROM alpine:3.13.5

COPY --from=builder /src/hello /src/hello

ENTRYPOINT [ "/src/hello" ]

CMD []
```
```
$ docker build -t hello-alpine -f Dockerfile-new .
Sending build context to Docker daemon   5.12kB
Step 1/8 : FROM gcc:9.4 AS builder
---> be1d0d9ce039
Step 2/8 : COPY hello.c /src/hello.c
---> Using cache
---> 70a624e3749b
Step 3/8 : WORKDIR /src
---> Using cache
---> 24e248c6b27c
Step 4/8 : RUN gcc --static -o hello hello.c
---> Using cache
---> db8ae7b42aff
Step 5/8 : FROM alpine:3.13.5
---> 6dbb9cc54074
Step 6/8 : COPY --from=builder /src/hello /src/hello
---> Using cache
---> 18c2bce629fb
Step 7/8 : ENTRYPOINT [ "/src/hello" ]
---> Using cache
---> 8dfb9d9d6010
Step 8/8 : CMD []
---> Using cache
---> 446baf852214
Successfully built 446baf852214
Successfully tagged hello-alpine:latest
$ docker image ls
REPOSITORY     TAG          IMAGE ID       CREATED       SIZE
hello-alpine   latest       446baf852214   2 hours ago   6.55MB
hello          latest       7cfa0cbe4e2a   2 hours ago   1.14GB
demo           latest       079bae887a47   2 hours ago   125MB
gcc            9.4          be1d0d9ce039   9 days ago    1.14GB
$ docker run --rm -it hello-alpine docker
hello docker
$ docker run --rm -it hello-alpine world
hello world
$ docker run --rm -it hello-alpine friends
hello friends
$
```
image is about 6.55MB.
First stage is to compile, and output a binary exe file
Second stage is to use the output file and run

# 5. try not to use root user

Root is dangerous
```dockerfile
FROM python:3.9.5-slim

RUN pip install flask && \
    groupadd -r flask && useradd -r -g flask flask && \
    mkdir /src && \
    chown -R flask:flask /src

USER flask

COPY app.py /src/app.py

WORKDIR /src
ENV FLASK_APP=app.py

EXPOSE 5000

CMD ["flask", "run", "-h", "0.0.0.0"]
```
```
$ docker image ls
REPOSITORY      TAG          IMAGE ID       CREATED          SIZE
flask-no-root   latest       80996843356e   41 minutes ago   126MB
flask-demo      latest       2696c68b51ce   49 minutes ago   125MB
python          3.9.5-slim   609da079b03a   2 weeks ago      115MB
```
```
$ docker run -d --name flask-root flask-demo
b31588bae216951e7981ce14290d74d377eef477f71e1506b17ee505d7994774
$ docker run -d --name flask-no-root flask-no-root
83aaa4a116608ec98afff2a142392119b7efe53617db213e8c7276ab0ae0aaa0
$ docker container ps
CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS      NAMES
83aaa4a11660   flask-no-root   "flask run -h 0.0.0.0"   4 seconds ago    Up 3 seconds    5000/tcp   flask-no-root
b31588bae216   flask-demo      "flask run -h 0.0.0.0"   16 seconds ago   Up 15 seconds   5000/tcp   flask-root
```
```
docker container exec -it flask-root sh
#
#
#
docker container exec -it flask-no-root sh
$
$
$
```
> [!IMPORTANT]
> **# means root user, $ means no-root user**

# 6. More reference

'Most important reference about dockerfile [Dockerfile_reference](https://docs.docker.com/reference/dockerfile/).

'dockerfile official image [Docker_official_image](https://github.com/docker-library/official-images).























