In this lesson, we will take a look at the various powerful tools in LangChain and how to use them.

In the previous lessons, we delved into the agents in LangChain. The future AI Agent is expected to be an agent system with an LLM as the core controller. **Tools are the extensions of the agent, acting as its weapons. The agent interacts with the world, controls, and transforms it through these tools**.

## Tools are Agent's weapons

LangChain is powerful for two main reasons: the strong reasoning ability of large models and the powerful execution ability of tools! Just like how the Monkey King, no matter how strong his magic, cannot subdue demons without his golden staff, a large model, no matter how capable of thinking, cannot function without tools.

Tools are functionalities that agents can use to interact with the world. These tools can be general utilities (such as search), other chains, or even other agents.

So, what exactly are tools? How do they function in LangChain?

LangChain provides a unified framework to integrate specific functionalities. Within this framework, each functionality is encapsulated as a tool. Each tool has its own inputs and outputs, as well as methods to process these inputs and generate outputs.

When an agent receives a task, it uses the reasoning of the large model to select the appropriate tool based on the type and requirements of the task. This selection process can be based on various strategies, such as the performance of the tool or its ability to handle specific types of tasks.

Once the appropriate tool is selected, LangChain passes the taskâ€™s input to the tool, which then processes the input and generates output. This output, after further reasoning by the large model, can be used as input for other tools or returned to the user as the final result.

![](images/709523/ebcyyaccd79133c03f417c45c225d1b6.png)

In this way, LangChain greatly extends the functionality of large models. The reasoning of the large model, combined with the invocation of tools, is integrated into one system that can handle various types of tasks. This improves the systemâ€™s flexibility and scalability, significantly simplifying the developerâ€™s work.

## How to Load Tools
In a program, you can use the following code snippet to load tools.

```plain
from langchain.agents import load_tools
tool_names = [...]
tools = load_tools(tool_names)

```
æŸäº›å·¥å…·ï¼ˆä¾‹å¦‚é“¾ã€ä»£ç†ï¼‰å¯èƒ½éœ€è¦ LLM æ¥åˆå§‹åŒ–å®ƒä»¬ã€‚

```plain
from langchain.agents import load_tools
tool_names = [...]
llm = ...
tools = load_tools(tool_names, llm=llm)

```
## LangChain tools overview

![](images/709523/e2f8a0318b4f1da7f0e756e87761d95b.jpg)

## Use arXiv tool to develop research assistance

Some tools, like SerpAPI, you have already used. Here, we will use the arXiv tool again. arXiv itself is a powerful tool for research papers, with more papers than top AI conferences, and earlier and more comprehensive. Integrating it into LangChain as a tool can greatly enhance your ability to stay updated with the latest academic progress.

arXiv is a free-access preprint repository where researchers can upload and share their work before formal publication. It was established in 1991, initially as a preprint database for physics, but later expanded to include fields such as mathematics, computer science, biology, and economics.

Preprints are papers completed by researchers but not yet peer-reviewed or formally published. arXiv allows researchers to upload these preprints so that others can view, comment on, and use the work before formal publication. This accelerates the dissemination and sharing of research findings, promoting academic exchange.

```plain
# è®¾ç½®OpenAI APIçš„å¯†é’¥
import os
os.environ["OPENAI_API_KEY"] = 'Your Key'

# å¯¼å…¥åº“
from langchain.chat_models import ChatOpenAI
from langchain.agents import load_tools, initialize_agent, AgentType

# åˆå§‹åŒ–æ¨¡å‹å’Œå·¥å…·
llm = ChatOpenAI(temperature=0.0)
tools = load_tools(
Â  Â  ["arxiv"],
)

# åˆå§‹åŒ–é“¾
agent_chain = initialize_agent(
Â  Â  tools,
Â  Â  llm,
Â  Â  agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
Â  Â  verbose=True,
)

# è¿è¡Œé“¾
agent_chain.run("ä»‹ç»ä¸€ä¸‹2005.14165è¿™ç¯‡è®ºæ–‡çš„åˆ›æ–°ç‚¹?")

```

é¦–å…ˆï¼Œæˆ‘ä»¬è¿˜æ˜¯æ¥ç ”ç©¶ä¸€ä¸‹ZERO\_SHOT\_REACT\_DESCRIPTIONè¿™ä¸ªAgentæ˜¯æ€ä¹ˆé€šè¿‡æç¤ºæ¥å¼•å¯¼æ¨¡å‹è°ƒç”¨å·¥å…·çš„ã€‚

> â€œpromptsâ€: \[
>
> Â  Â  "Answer the following questions as best you can. You have access to the following tools:\\n\\n

é¦–å…ˆå‘Šè¯‰æ¨¡å‹ï¼Œè¦å°½åŠ›å›ç­”é—®é¢˜ï¼Œä½†æ˜¯å¯ä»¥è®¿é—®ä¸‹é¢çš„å·¥å…·ã€‚

> **arxiv:** A wrapper around Arxiv.org Useful for when you need to answer questions about Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering, and Economics from scientific articles on arxiv.org. Input should be a search query.\\n\\n

æŒ‡å¯¼æ¨¡å‹è¾“å‡ºä¸‹é¢çš„å†…å®¹ã€‚

> Question: the input question you must answer\\n ï¼ˆé—®é¢˜ï¼šéœ€è¦å›ç­”çš„é—®é¢˜ï¼‰
>
> Thought: you should always think about what to do\\n ï¼ˆæ€è€ƒï¼šåº”è¯¥æ€»æ˜¯æ€è€ƒä¸‹ä¸€æ­¥åšä»€ä¹ˆï¼‰
>
> Action: the action to take, should be one of \[arxiv\]\\n ï¼ˆè¡ŒåŠ¨ï¼šä»å…·ä½“å·¥å…·åˆ—è¡¨ä¸­é€‰æ‹©è¡ŒåŠ¨â€”â€”è¿™é‡Œåªæœ‰arxivä¸€ä¸ªå·¥å…·ï¼‰
>
> Action Input: the input to the action\\n ï¼ˆè¡ŒåŠ¨çš„è¾“å…¥ï¼šè¾“å…¥å·¥å…·çš„å†…å®¹ï¼‰
>
> Observation: the result of the action\\nâ€¦ ï¼ˆè§‚å¯Ÿï¼šå·¥å…·è¿”å›çš„ç»“æœï¼‰
>
> (this Thought/Action/Action Input/Observation can repeat N times)\\n ï¼ˆä¸Šé¢ Thought/Action/Action Input/Observation çš„è¿‡ç¨‹å°†é‡å¤Næ¬¡ï¼‰
>
> Thought: I now know the final answer\\n ï¼ˆç°åœ¨æˆ‘çŸ¥é“æœ€ç»ˆç­”æ¡ˆäº†ï¼‰
>
> Final Answer: the final answer to the original input question\\n\\n ï¼ˆåŸå§‹é—®é¢˜çš„æœ€ç»ˆç­”æ¡ˆï¼‰

> **Begin!**\\n\\n

ç°åœ¨å¼€å§‹ï¼

> **Question**: 'Chain-of-Thought Prompting Elicits Reasoning in Large Language Modelsâ€™è¿™ç¯‡è®ºæ–‡çš„åˆ›æ–°ç‚¹\\n

çœŸæ­£çš„é—®é¢˜åœ¨æ­¤ã€‚

> Thought:"

å¼€å§‹æ€è€ƒå§ï¼

ç„¶åï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹Chainçš„è¿è¡Œè¿‡ç¨‹ã€‚

![](images/709523/6e1195d608d47fbe5b67131c1fe32357.jpg)

å…¶ä¸­ï¼Œä»£ç†çš„æ€è€ƒè¿‡ç¨‹ä¸­çš„ç¬¬ä¸€ä¸ªè¿”å›ç»“æœå¦‚ä¸‹ï¼š

> â€œtextâ€: " I need to read the paper to understand the innovation\\n ï¼ˆæ€è€ƒï¼šæˆ‘éœ€è¦é˜…è¯»æ–‡ç« æ‰èƒ½ç†è§£åˆ›æ–°ç‚¹ï¼‰
>
> Action: arxiv\\n ï¼ˆè¡ŒåŠ¨ï¼šarxivå·¥å…·ï¼‰
>
> Action Input: â€˜Chain-of-Thought Prompting Elicits Reasoning in Large Language Modelsâ€™", ï¼ˆè¡ŒåŠ¨çš„è¾“å…¥ï¼šè®ºæ–‡çš„æ ‡é¢˜ï¼‰

> Thought: I now know the final answer

## LangChain tool kits overview

![](images/709523/c87be0638409b278c2657a66f45aa927.jpg)

## Use Gmail tool kits to develop personal assistance

Earlier, you used the arXiv tool to assist with some research work. Naturally, you want your AI Agent to become your all-purpose assistant, capable of checking emails, drafting messages, and even writing documents, right?

LangChain can certainly handle all of this!

- With the Gmail toolkit, you can use LangChain applications to check emails, delete spam, and even draft emails.
- With the Office365 toolkit, you can have LangChain applications read and write documents, summarize them, and even create PowerPoint presentations.
- With the GitHub toolkit, you can instruct LangChain applications to check the latest code, commit changes, merge branches, and even attempt to automatically answer issuesâ€”since large models are inherently good at solving code problems.
These are no longer just dreams.

Letâ€™s start with a simple application.

**Goal: I want the AI application to access my Gmail, check my inbox every morning, and see if the customer service from â€œEasy Speed Flowersâ€ has sent me any messages. (Because I might be anxiously waiting for their refund ğŸ˜)**

Letâ€™s get started.

## Step 1: Set Up Your Application Interface in Google Cloud
You need to follow the official Gmail API configuration link to complete this step. This is unrelated to LangChain. Itâ€™s quite complex, so youâ€™ll need some patience. Just follow the steps in the guide.

Below are some screenshots I took during this setup process, just for your reference. For detailed configuration, you should follow Googleâ€™s official instructions.
![](images/709523/8a3c72f48c231bd2d886b4d99e9f3321.jpg)

![](images/709523/3822d1effb90c855c133acdecea2eaab.jpg)

![](images/709523/96a788e8a1f7d4f32e3d23eb94cce8f3.jpg)

![](images/709523/0f746cfa48ba60c0fe98e657cb3yyb29.jpg)

ä¸‹é¢è¿™ä¸ªOAuthåŒæ„å±å¹•é‡Œé¢çš„é…ç½®éå¸¸é‡è¦ï¼Œä½ çš„æ™ºèƒ½ä»£ç†èƒ½åšä»€ä¹ˆï¼Œä¸èƒ½åšä»€ä¹ˆï¼Œå°±çœ‹ä½ æ€ä¹ˆç»™æƒé™äº†ï¼

![](images/709523/195ec3590bb075ecff42911f13d2f22f.jpg)

æ‰€æœ‰è®¾ç½®éƒ½å®Œæˆä¹‹åï¼Œåœ¨OAuthå®¢æˆ·æ®µå·²åˆ›å»ºè¿™ä¸ªé¡µé¢ï¼Œä½ æ‹¥æœ‰äº†å¼€å‘å¯†é’¥ã€‚

![](images/709523/f6829a70c320161a1002ee3380c5b1b0.jpg)

## Step 2: Generate development Token with keys

```plain
pip install --upgrade google-api-python-client
pip install --upgrade google-auth-oauthlib
pip install --upgrade google-auth-httplib2

```

ç„¶åï¼ŒæŠŠå¯†é’¥ä¸‹è½½ä¸‹æ¥ï¼Œä¿å­˜ä¸ºcredentials.jsonã€‚

è¿è¡Œä¸‹é¢çš„ä»£ç ï¼Œç”Ÿæˆtoken.jsonã€‚

```plain
from __future__ import print_function

import os.path

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# If modifying these scopes, delete the file token.json.
SCOPES = ['https://www.googleapis.com/auth/gmail.readonly']

def main():
Â  Â  """Shows basic usage of the Gmail API.
Â  Â  Lists the user's Gmail labels.
Â  Â  """
Â  Â  creds = None
Â  Â  # The file token.json stores the user's access and refresh tokens, and is
Â  Â  # created automatically when the authorization flow completes for the first
Â  Â  # time.
Â  Â  if os.path.exists('token.json'):
Â  Â  Â  Â  creds = Credentials.from_authorized_user_file('token.json', SCOPES)
Â  Â  # If there are no (valid) credentials available, let the user log in.
Â  Â  if not creds or not creds.valid:
Â  Â  Â  Â  if creds and creds.expired and creds.refresh_token:
Â  Â  Â  Â  Â  Â  creds.refresh(Request())
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  flow = InstalledAppFlow.from_client_secrets_file(
Â  Â  Â  Â  Â  Â  Â  Â  'credentials.json', SCOPES)
Â  Â  Â  Â  Â  Â  creds = flow.run_local_server(port=8088)
Â  Â  Â  Â  # Save the credentials for the next run
Â  Â  Â  Â  with open('token.json', 'w') as token:
Â  Â  Â  Â  Â  Â  token.write(creds.to_json())

Â  Â  try:
Â  Â  Â  Â  # Call the Gmail API
Â  Â  Â  Â  service = build('gmail', 'v1', credentials=creds)
Â  Â  Â  Â  results = service.users().labels().list(userId='me').execute()
Â  Â  Â  Â  labels = results.get('labels', [])

Â  Â  Â  Â  if not labels:
Â  Â  Â  Â  Â  Â  print('No labels found.')
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  print('Labels:')
Â  Â  Â  Â  for label in labels:
Â  Â  Â  Â  Â  Â  print(label['name'])

Â  Â  except HttpError as error:
Â  Â  Â  Â  # TODO(developer) - Handle errors from gmail API.
Â  Â  Â  Â  print(f'An error occurred: {error}')

if __name__ == '__main__':
Â  Â  main()

```

è¿™æ˜¯Google APIç½‘ç«™æä¾›çš„æ ‡å‡†ç¤ºä¾‹ä»£ç ï¼Œé‡Œé¢ç»™äº†è¯»å–æƒé™ï¼ˆgmail.readonlyï¼‰çš„Tokenï¼Œå¦‚æœä½ è¦ç¼–å†™é‚®ä»¶ï¼Œç”šè‡³å‘é€é‚®ä»¶ï¼Œéœ€è¦æ ¹æ®éœ€æ±‚æ¥è°ƒæ•´æƒé™ã€‚æ›´å¤šç»†èŠ‚å¯ä»¥å‚é˜…Google APIçš„ [æ–‡æ¡£](https://cloud.google.com/compute/docs/apis?hl=zh-cn)ã€‚

è¿™ä¸ªç¨‹åºä¼šç”Ÿæˆä¸€ä¸ªtoken.jsonæ–‡ä»¶ï¼Œæ˜¯æœ‰ç›¸å…³æƒé™çš„å¼€å‘ä»¤ç‰Œã€‚è¿™ä¸ªæ–‡ä»¶åœ¨LangChainåº”ç”¨ä¸­éœ€è¦å’Œå¯†é’¥ä¸€èµ·ä½¿ç”¨ã€‚

![](images/709523/541c541b377063b49d74ddc53f41d578.jpg)

æŠŠå¯†é’¥å’ŒTokenæ–‡ä»¶éƒ½æ”¾åœ¨ç¨‹åºçš„åŒä¸€ä¸ªç›®å½•ä¸­ï¼Œä½ å°±å¯ä»¥å¼€å§‹å¼€å‘åº”ç”¨ç¨‹åºäº†ã€‚

![](images/709523/f23144b35b44fef8d900d0d50c9da6b4.jpg)

### Step 3: Use LangChain framework to develop Gmail App

è¿™æ®µä»£ç çš„æ ¸å¿ƒç›®çš„æ˜¯è¿æ¥åˆ°Gmail APIï¼ŒæŸ¥è¯¢ç”¨æˆ·çš„é‚®ä»¶ï¼Œå¹¶é€šè¿‡LangChainçš„Agentæ¡†æ¶æ™ºèƒ½åŒ–åœ°è°ƒç”¨APIï¼ˆç”¨è¯­è¨€è€Œä¸æ˜¯å…·ä½“APIï¼‰ï¼Œä¸é‚®ä»¶è¿›è¡Œäº’åŠ¨ã€‚

```plain
# è®¾ç½®OpenAI APIçš„å¯†é’¥
import os
os.environ["OPENAI_API_KEY"] = 'Your Key'

# å¯¼å…¥ä¸Gmailäº¤äº’æ‰€éœ€çš„å·¥å…·åŒ…
from langchain.agents.agent_toolkits import GmailToolkit

# åˆå§‹åŒ–Gmailå·¥å…·åŒ…
toolkit = GmailToolkit()

# ä»gmailå·¥å…·ä¸­å¯¼å…¥ä¸€äº›æœ‰ç”¨çš„åŠŸèƒ½
from langchain.tools.gmail.utils import build_resource_service, get_gmail_credentials

# è·å–Gmail APIçš„å‡­è¯ï¼Œå¹¶æŒ‡å®šç›¸å…³çš„æƒé™èŒƒå›´
credentials = get_gmail_credentials(
Â  Â  token_file="token.json",Â  # Tokenæ–‡ä»¶è·¯å¾„
Â  Â  scopes=["https://mail.google.com/"],Â  # å…·æœ‰å®Œå…¨çš„é‚®ä»¶è®¿é—®æƒé™
Â  Â  client_secrets_file="credentials.json",Â  # å®¢æˆ·ç«¯çš„ç§˜å¯†æ–‡ä»¶è·¯å¾„
)
# ä½¿ç”¨å‡­è¯æ„å»ºAPIèµ„æºæœåŠ¡
api_resource = build_resource_service(credentials=credentials)
toolkit = GmailToolkit(api_resource=api_resource)

# è·å–å·¥å…·
tools = toolkit.get_tools()
print(tools)

# å¯¼å…¥ä¸èŠå¤©æ¨¡å‹ç›¸å…³çš„åŒ…
from langchain.chat_models import ChatOpenAI
from langchain.agents import initialize_agent, AgentType

# åˆå§‹åŒ–èŠå¤©æ¨¡å‹
llm = ChatOpenAI(temperature=0, model='gpt-4')

# é€šè¿‡æŒ‡å®šçš„å·¥å…·å’ŒèŠå¤©æ¨¡å‹åˆå§‹åŒ–agent
agent = initialize_agent(
Â  Â  tools=toolkit.get_tools(),
Â  Â  llm=llm,
Â  Â  agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
)

# ä½¿ç”¨agentè¿è¡Œä¸€äº›æŸ¥è¯¢æˆ–æŒ‡ä»¤
result = agent.run(
Â  Â  "ä»Šå¤©æ˜“é€Ÿé²œèŠ±å®¢æœç»™æˆ‘å‘é‚®ä»¶äº†ä¹ˆï¼Ÿæœ€æ–°çš„é‚®ä»¶æ˜¯è°å‘ç»™æˆ‘çš„ï¼Ÿ"
)

# æ‰“å°ç»“æœ
print(result)

```

ä»£ç çš„æ ¸å¿ƒéƒ¨åˆ†ä¸»è¦æ˜¯è¿æ¥åˆ°Gmail APIï¼Œè·å–ç”¨æˆ·çš„é‚®ä»¶æ•°æ®ï¼Œå¹¶é€šè¿‡ç‰¹å®šçš„ Agent æŸ¥è¯¢è¿™äº›æ•°æ®ã€‚

ä½ çš„è¯·æ±‚æ˜¯æŸ¥è¯¢ä»Šå¤©æ˜¯å¦æ”¶åˆ°äº†æ¥è‡ªâ€œæ˜“é€Ÿé²œèŠ±å®¢æœâ€çš„é‚®ä»¶ï¼Œä»¥åŠæœ€æ–°é‚®ä»¶çš„å‘é€è€…æ˜¯è°ã€‚ **è¿™ä¸ªè¯·æ±‚æ˜¯æ¨¡ç³Šçš„ï¼Œæ˜¯è‡ªç„¶è¯­è¨€æ ¼å¼ï¼Œå…·ä½“è°ƒç”¨ä»€ä¹ˆAPIï¼Œç”±Agentã€Toolä¹Ÿå°±æ˜¯Gmail APIå®ƒä¿©å•†é‡ç€æ¥ã€‚** è¿™ä¸æˆ‘ä»¬ä¹‹å‰æ‰€è¿›è¡Œçš„æ¸…æ™°çš„ã€å…·ä½“APIè°ƒç”¨å¼çš„åº”ç”¨å¼€å‘è¿¥ç„¶ä¸åŒã€‚

ç¬¬ä¸€æ¬¡è¿è¡Œç¨‹åºï¼Œä¼šè¿›è¡Œä¸€äº›ç¡®è®¤ï¼Œå¹¶è®©æˆ‘Loginæˆ‘çš„Gmailã€‚

![](images/709523/0e2a7df295caa50512552e05ea3def37.jpg)

![](images/709523/3208ff117674ebf3f08eac6118393e51.jpg)

![](images/709523/0cc81560c4bc412104b5144a474c5530.jpg)

ä¹‹åï¼Œæˆ‘å°±å¾—åˆ°äº†æ™ºèƒ½åŠ©æ‰‹çš„å›ç­”ï¼

![](images/709523/455f8cb0138cd3860869e5eee74f8ecf.jpg)

å¥¹è¯´ï¼š **ä¸»äººï¼Œçœ‹èµ·æ¥ä½ æ²¡æœ‰æ”¶åˆ°â€œæ˜“é€Ÿé²œèŠ±â€çš„é‚®ä»¶è€¶ï¼Œè¿˜éœ€è¦æˆ‘å¸®ä½ åšäº›ä»€ä¹ˆå—ï¼Ÿ** çœŸçš„å¾ˆè´´å¿ƒï¼Œè¿™æ ·çš„è¯ï¼Œæˆ‘æ¯å¤©æ—©æ™¨å°±ä¸éœ€è¦è‡ªå·±å»æ£€æŸ¥é‚®ä»¶å•¦ï¼

åæ¥ï¼Œæˆ‘åˆé—®å¥¹ï¼Œé‚£ä¹ˆè°ç»™æˆ‘å‘æ¥äº†æ–°é‚®ä»¶å‘¢ï¼Ÿ

![](images/709523/c95a8e75cdc78a7da4960c8f2yyf8be4.jpg)

å¥¹å‘Šè¯‰æˆ‘è¯´ï¼ŒMedium - Programing ç»™æˆ‘å‘äº†ä¸€ç¯‡ VS code çš„ 10 ä¸ª tips çš„æ–‡ç« ï¼Œè¿˜æœ‰Kubernetesçš„ç‚¹å­å•¥çš„ã€‚

å—¯ï¼Œè¿™æ˜¯æˆ‘è®¢é˜…çš„å†…å®¹ã€‚ä¸‹ä¸€æ­¥ï¼Œæˆ‘è¿˜å¯ä»¥è®©å¥¹é’ˆå¯¹è¿™äº›å†…å®¹ç»™æˆ‘æ€»ç»“æ€»ç»“ï¼è¿™ä¹Ÿæ˜¯å¥¹çš„å¼ºé¡¹ï¼

## Summary

By now, you should have a deeper understanding of the core value of LangChain. Its value lies in encapsulating and abstracting the complexity of model operation and interaction, providing developers with a simpler and more intuitive interface to leverage large models.

- Integration of Multiple Models and Strategies: LangChain offers a method that allows multiple models or strategies to work within a unified framework. For example, arXiv is a standalone tool that handles specific tasks. This tool can coexist with other tools (such as those for handling natural language queries or database queries) as part of an integrated system. This way, you can easily create a system that can handle various types of inputs and perform multiple tasks without writing separate code for each task.
- Easier Interaction and Maintenance: With LangChain, you can more conveniently manage and maintain your tools and models. The abstraction of tools and agents provided by LangChain allows developers to shift their focus from low-level implementation details to high-level application logic. Moreover, LangChain encapsulates tasks such as model loading, input-output processing, and tool scheduling, enabling developers to concentrate on how to combine these tools to solve real-world problems.
- Adaptability: The architecture provided by LangChain allows you to easily add new tools or models or replace existing ones. This flexibility makes it easy for your system to adapt to new requirements or changes.
- Explainability: LangChain also provides explainability for model decisions. In your example, the conversation history and tool selection records provided by LangChain can help understand why the system made certain decisions.

Overall, while directly calling models may be sufficient for single tasks or simple applications, using a framework like LangChain can greatly simplify your work when dealing with more complex scenarios, such as coordinating multiple models or tools or handling various types of inputs.

































